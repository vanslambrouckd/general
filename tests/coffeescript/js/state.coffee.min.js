(function() {
  var Camera3, User, calculateCost, calculateNumberSold, calculateProfit, calculateRevenue, cost, factorial, loadProductData, loadUserData, logUserDataFor, makeDbOperator, makeLoadData, makeSaveData, nr, numberSold, phototake500, price, profit, revenue, revenueBetween, saveProductData, sold, tax, withCachedCallback, _i, _j,
    __slice = [].slice;

  numberSold = function(salePrice) {
    return 50 + 20 / 10 * (200 - salePrice);
  };

  console.log(numberSold(10));

  console.log(numberSold(20));

  console.log(numberSold(200));

  console.log(numberSold(1));

  numberSold = 5;

  calculateNumberSold = function(salePrice) {
    return numberSold = 50 + 20 / 10 * (200 - salePrice);
  };

  calculateRevenue = function(salePrice) {
    return numberSold * salePrice;
  };

  console.clear;

  for (price = _i = 140; _i <= 145; price = ++_i) {
    calculateNumberSold(price);
    console.log(calculateRevenue(price));
  }

  numberSold = 0;

  calculateNumberSold = function(salePrice) {
    return numberSold = 50 + 20 / 10 * (200 - salePrice);
  };

  calculateRevenue = function(salePrice, callback) {
    return callback(numberSold * salePrice);
  };

  revenueBetween = function(start, finish) {
    var addToTotals, totals, _j;
    totals = [];
    for (price = _j = start; start <= finish ? _j <= finish : _j >= finish; price = start <= finish ? ++_j : --_j) {
      calculateNumberSold(price);
      addToTotals = function(result) {
        return totals.push(result);
      };
      calculateRevenue(price, addToTotals);
    }
    return totals;
  };

  console.log(revenueBetween(140, 145));


  /*
  example1
  no properties set on the object; its all method cals
  none of the method calls change any properties on the object
  => good
   */

  Camera3 = (function() {
    function Camera3() {}

    Camera3.prototype.overhead = function() {
      return 140;
    };

    Camera3.prototype.costPrice = function() {
      return 100;
    };

    Camera3.prototype.profit = function(salePrice) {
      return (this.revenue(salePrice)) - (this.cost(salePrice));
    };

    Camera3.prototype.numberSold = function(salePrice) {
      return 50 + 20 / 10 * (200 - salePrice);
    };

    Camera3.prototype.revenue = function(salePrice) {
      return (this.numberSold(salePrice)) * salePrice;
    };

    Camera3.prototype.cost = function(salePrice) {
      return this.overhead() + (this.numberSold(salePrice)) + this.costPrice();
    };

    return Camera3;

  })();

  console.clear;

  console.log("jaaa");

  phototake500 = new Camera3;

  console.log(phototake500.profit(162));


  /*
  example2
  -> bad: avoid state in variables
   */

  revenue = 0;

  cost = 0;

  sold = 0;

  calculateRevenue = function(salePrice) {
    return revenue = sold * salePrice;
  };

  calculateCost = function(salePrice) {
    return cost = 140 + sold * 100;
  };

  calculateNumberSold = function(salePrice) {
    return sold = 50 + 20 / 10 * (200 - salePrice);
  };

  calculateProfit = function(salePrice) {
    calculateNumberSold(salePrice);
    calculateRevenue(salePrice);
    calculateCost(salePrice);
    return revenue - costPrice;
  };

  loadUserData = function(user, callback) {
    return users.get(user, function(data) {
      return callback(data);
    });
  };

  loadProductData = function(product, callback) {
    return products.get(product, function(data) {
      return callback(data);
    });
  };

  makeLoadData = function(db) {
    return function(entry, callback) {
      return db.get(entry, function(data) {
        return callback(data);
      });
    };
  };

  makeSaveData = function(type) {
    return function(entry, value, callback) {
      return db.set(entry, value, typeof callback === "function" ? callback() : void 0);
    };
  };

  loadUserData = makeLoadData('user');

  makeDbOperator = function(db) {
    return function(operation) {
      return function() {
        var entry, params;
        entry = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return db[operation].apply(db, [entry].concat(__slice.call(params)));
      };
    };
  };

  loadProductData = (makeDbOperator('product'))('get');

  saveProductData = (makeDbOperator('product'))('set');


  /*
  when functions are the basic building block, 
  abstractions are done with the same basic function glue:
  invoking a function, passing a function as an argument
  and returning a function
   */

  withCachedCallback = function(fn) {
    var cache;
    cache = Object.create(null);
    return function() {
      var callback, key, params, paramsCopy;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      key = params[0];
      callback = params[params.length - 1];
      if (key in cache) {
        return callback.apply(null, cache[key]);
      } else {
        paramsCopy = params.slice(0);
        paramsCopy[params.length - 1] = function() {
          var params;
          params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          cache[key] = params;
          return callback(params);
        };
        return fn(paramsCopy);
      }
    };
  };

  loadProductData = withCachedCallback((makeDbOperator(products))('get'));


  /*
  memoization:
  caching the evaluation of a function with specific arguments is called memoization
   */

  factorial = function(n) {
    if (n === 0) {
      return 1;
    } else {
      return n * (factorial(n - 1));
    }
  };

  for (nr = _j = 3; _j <= 5; nr = ++_j) {
    console.log(factorial(nr));
  }

  User = (function() {
    function User() {}

    User.get = function() {};

    return User;

  })();

  logUserDataFor = function(user) {
    var dbRequest;
    dbRequest = function() {
      return user.get(user, function(error, data) {
        if (error) {
          return dbRequest();
        } else {
          return console.log('Got the data');
        }
      });
    };
    return dbRequest();
  };

  profit = function() {};

  tax = function(amount) {
    return amount / 3;
  };


  /*
  netProfit = (products) ->
    profits = (profit product) for product in products
    profits.reduce(acc, p) ->
      acc + p
  	
  netProfitForProducts = netProfit products
  taxForProducts = tax NetProfitForProducts
  
  userSpend = (user) ->
    spend = 100
    
  loyalDiscount = (spend) ->
    if spend < 1000 then 0
    else if spend < 5000 then 5
    else if spend < 10000 then 10  
    else if spend < 50000 then 20    
    else if spend > 50000 then 40    
    
  fredSpend = userSpend 'fred'
  loyaltyDiscountForFred = loyaltyDiscount fredSpend
   *#p169
  console.log loyaltyDiscountForFred
   */

}).call(this);
